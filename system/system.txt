id a = a

dot a b c = a (b c)
dot2 a b c d = a (b c d)

b1 a * = a
b0 * a = a

extract (* a) = a

----------------------------------------------------------------------------------------------------

Wrap:
  wrap a = Wrap a

----------------------------------------------------------------------------------------------------

Pair:
  pair a b = Pair a b

fst (Pair a *) = a
snd (Pair * a) = a

----------------------------------------------------------------------------------------------------

Bool:
  bool a:True = Bool a
  bool a:False = Bool a

True:
  true = True

False:
  false = False

not True = false
not False = true

bnot (Bool a) = bool (not a)

or True * = true
or False a = a

and False * = false
and True a = a

eq a a = true
eq * * = false

ite True = b1
ite False = b0

----------------------------------------------------------------------------------------------------

Nat:
  nat a:Zero = Nat a
  nat a:(Succ *) = Nat a

Zero:
  zero = Zero

Succ:
  succ_ (Nat a) = Succ a

succ a = succ_ (nat a)

for f z Zero = z
for f z (Succ a) = f (for f z a)

----------------------------------------------------------------------------------------------------

List:
  list a:(Nil ~t) = List ~t a
  list a:(Cons ~t * *) = List ~t a

Nil:
  nil ~t = Nil ~t

Cons:
  cons_ a:(t *) (List ~t b) = Cons ~t a b

cons a b = cons_ a (list b)

head (Cons * a *) = a
tail (Cons * * a) = a

singleton a:(t *) = cons a (nil ~t)

map ~t f (Nil *) = nil ~t
map ~t f (Cons * x xs) = cons (f x) (map ~t f xs)

foldl f z (Nil *) = z
foldl f z (Cons * x xs) = foldl f (f z x) xs

foldr f z (Nil *) = z
foldr f z (Cons * x xs) = f x (foldr f z xs)

length = foldl (dot2 succ b1) zero

all f list = foldl (all_1 f) true list
all_1 f a b = and a (f b)

any f list = foldl (any_1 f) false list
any_1 f a b = or a (f b)

rawList ~t f = rawList_ f (nil ~t)
rawList_ f list &nil = list
rawList_ f list a = rawList_ f (cons (f a) list)

----------------------------------------------------------------------------------------------------

Pred:
  pred a:(Pident *) = Pred a
  pred a:(Impl * *) = Pred a
  pred a:(Pnot *) = Pred a
  pred a:(Forall * *) = Pred a
  pred a:(Pelem * *) = Pred a

Pident:
  pident_ (Nat a) = Pident a

Impl:
  impl_ (Pred a) (Pred b) = Impl a b

Pnot:
  pnot_ (Pred a) = Pnot a

Forall:
  forall_ (Nat a) (Pred b) = Forall a b

Pelem:
  pelem_ (Nat a) (Nat b) = Pelem a b

pident a = pident_ (nat a)
impl a b = impl_ (pred a) (pred b)
pnot a = pnot_ (pred a)
forall a b = forall_ (nat a) (pred b)
pelem a b = pelem_ (nat a) (nat b)

a. = pident zero
b. = nextPident a.
c. = nextPident b.
d. = nextPident c.

nextPident (Pident a) = pident (succ a)

substPident pident:(Pident *) p pident = p
substPident pident:(Pident *) p a:(Pident *) = a
substPident pident:(Pident *) p (Impl a b) = impl (substPident pident p a) (substPident pident p b)
substPident pident:(Pident *) p (Pnot a) = pnot (substPident pident p a)
substPident pident:(Pident *) p (Forall a b) = forall a (substPident pident p b)
substPident pident:(Pident *) p a:(Pelem * *) = a

substIdent ident1 ident2 (Impl a b) = impl (substIdent ident1 ident2 a) (substIdent ident1 ident2 b)
substIdent ident1 ident2 (Pnot a) = pnot (substIdent ident1 ident2 a)
substIdent ident1 ident2 x:(Forall ident1 b) = x
substIdent ident1 ident2 (Forall a b) = forall a (substIdent ident1 ident2 b)
substIdent ident1 ident2 (Pelem a b) = pelem (replaceIdent ident1 ident2 a) (replaceIdent ident1 ident2 b)

replaceIdent ident1 ident2 ident1 = ident2
replaceIdent ident1 ident2 * = ident1

hasPident pident:(Pident *) pident = true
hasPident pident:(Pident *) (Pident *) = false
hasPident pident:(Pident *) (Impl a b) = or (hasPident pident a) (hasPident pident b)
hasPident pident:(Pident *) (Pnot a) = hasPident pident a
hasPident pident:(Pident *) (Forall * a) = hasPident pident a
hasPident pident:(Pident *) (Pelem a b) = false

hasFreeIdent ident (Impl a b) = or (hasFreeIdent ident a) (hasFreeIdent ident b)
hasFreeIdent ident (Pnot a) = hasFreeIdent ident a
hasFreeIdent ident (Forall ident *) = false
hasFreeIdent ident (Forall * a) = hasFreeIdent ident a
hasFreeIdent ident (Pelem a b) = or (eq a ident) (eq b ident)

nextAvailPident pident (Nil ~Pred) = pident
nextAvailPident pident list:(Cons ~Pred * *) = ite (any (nextAvailPident_1 pident) list)
  nextAvailPident_2 nextAvailPident_3 pident list
nextAvailPident_1 pident (Pred p) = hasPident pident p
nextAvailPident_2 pident p = nextAvailPident (nextPident pident) p
nextAvailPident_3 pident p = pident

availPidentsList list Zero = nil ~Pident
availPidentsList list (Succ a) = cons
  (nextAvailPident a. list)
  (availPidentsList (cons (pred (nextAvailPident a. list)) list) a)

----------------------------------------------------------------------------------------------------

Proof:
  rule.inst_ ident:(Pident *) (Pred p) (Proof phi) = Proof (substPident ident p phi)
  rule.mp (Proof (Impl a b)) (Proof a) = Proof b

  ax.prop.1 = Proof (impl a. (impl b. a.))
  ax.prop.2 = Proof (impl (impl a. (impl b. c.)) (impl (impl a. b.) (impl a. c.)))
  ax.prop.3 = Proof (impl (impl (pnot a.) (pnot b.)) (impl b. a.))

rule.inst a b c = rule.inst_ a (pred b) c

proof2pred (Proof a) = pred a

----------------------------------------------------------------------------------------------------

util.prop.inst proof list = util.prop.inst_availPidents proof list
util.prop.inst_availPidents proof list = availPidentsList
  (foldl util.prop.inst_availPidents_1 (singleton (proof2pred proof)) list)
  (length list)
util.prop.inst_availPidents_1 list (Wrap (Pair pident p)) = cons (pred pident) (cons (pred p) list)

-- util.prop.sup.add proof sup = rule.mp
--   (rule.inst th.prop.ax1.a.b)
--   proof

----------------------------------------------------------------------------------------------------

-- a -> b -> a
th.prop.ax1.a.b = ax.prop.1

-- a -> (b -> a) -> a
th.prop.ax1.a.ba = rule.inst b. (impl b. a.) th.prop.ax1.a.b

-- (a -> b -> c) -> (a -> b) -> a -> c
th.prop.ax2.a.b.c = ax.prop.2

-- (a -> b -> a) -> (a -> b) -> a -> a
th.prop.ax2.a.b.a = rule.inst c. a. th.prop.ax2.a.b.c

-- (a -> (b -> a) -> a) -> (a -> b -> a) -> a -> a
th.prop.ax2.a.ba.a = rule.inst b. (impl b. a.) th.prop.ax2.a.b.a

-- (a -> b -> a) -> a -> a
th.prop.impl.ax1ab.refl = rule.mp th.prop.ax2.a.ba.a th.prop.ax1.a.ba

-- a -> a
th.prop.impl.refl = rule.mp th.prop.impl.ax1ab.refl th.prop.ax1.a.b

----------------------------------------------------------------------------------------------------

main = util.prop.inst th.prop.impl.refl mlist

mlist = rawList ~Wrap wrap
  (pair a. a.)
  nil