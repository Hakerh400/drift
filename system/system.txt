id a = a

dot a b c = a (b c)
dot2 a b c d = a (b c d)

b1 a * = a
b0 * a = a

extract (* a) = a

----------------------------------------------------------------------------------------------------

Nil:
  nil = Nil

----------------------------------------------------------------------------------------------------

Pair:
  pair a b = Pair a b

fst (Pair a *) = a
snd (Pair * a) = a

----------------------------------------------------------------------------------------------------

True:
  true = True

False:
  false = False

not True = false
not False = true

or True * = true
or False a = a

and False * = false
and True a = a

eq a a = true
eq * * = false

ite True = b1
ite False = b0

----------------------------------------------------------------------------------------------------

Zero:
  zero = Zero

Succ:
  succ a = Succ a

for f z Zero = z
for f z (Succ a) = f (for f z a)

unstrict Strict.Zero = zero
unstrict (Strict.Succ a) = succ (unstrict a)

----------------------------------------------------------------------------------------------------

Strict.Nat:
  strict.nat a:Strict.Zero = Strict.Nat a
  strict.nat a:(Strict.Succ *) = Strict.Nat a

Strict.Zero:
  strict.zero = Strict.Zero

Strict.Succ:
  strict.succ_ (Strict.Nat a) = Strict.Succ a

strict.succ a = strict.succ_ (strict.nat a)

----------------------------------------------------------------------------------------------------

head (Pair * a *) = a
tail (Pair * * a) = a

singleton a = pair a nil

map f Nil = nil
map f (Pair x xs) = pair (f x) (map f xs)

foldl f z Nil = z
foldl f z (Pair x xs) = foldl f (f z x) xs

foldr f z Nil = z
foldr f z (Pair x xs) = f x (foldr f z xs)

all f list = foldl (all_1 f) true list
all_1 f a b = and a (f b)

any f list = foldl (any_1 f) false list
any_1 f a b = or a (f b)

rawList = rawList_ nil
rawList_ list Nil = list
rawList_ list a = rawList_ (pair a list)

length = foldl (dot2 succ b1) zero

----------------------------------------------------------------------------------------------------

Pred:
  pred a:(Pident *) = Pred a
  pred a:(Impl * *) = Pred a
  pred a:(Pnot *) = Pred a
  pred a:(Forall * *) = Pred a
  pred a:(Pelem * *) = Pred a

Pident:
  pident_ (Strict.Nat a) = Pident a

Impl:
  impl_ (Pred a) (Pred b) = Impl a b

Pnot:
  pnot_ (Pred a) = Pnot a

Forall:
  forall_ (Strict.Nat a) (Pred b) = Forall a b

Pelem:
  pelem_ (Strict.Nat a) (Strict.Nat b) = Pelem a b

pident a = pident_ (strict.nat a)
impl a b = impl_ (pred a) (pred b)
pnot a = pnot_ (pred a)
forall a b = forall_ (strict.nat a) (pred b)
pelem a b = pelem_ (strict.nat a) (strict.nat b)

a. = pident strict.zero
b. = nextPident a.
c. = nextPident b.
d. = nextPident c.

nextPident (Pident a) = pident (strict.succ a)

substPident pident:(Pident *) p pident = p
substPident pident:(Pident *) p a:(Pident *) = a
substPident pident:(Pident *) p (Impl a b) = impl (substPident pident p a) (substPident pident p b)
substPident pident:(Pident *) p (Pnot a) = pnot (substPident pident p a)
substPident pident:(Pident *) p (Forall a b) = forall a (substPident pident p b)
substPident pident:(Pident *) p a:(Pelem * *) = a

substIdent ident1 ident2 (Impl a b) = impl (substIdent ident1 ident2 a) (substIdent ident1 ident2 b)
substIdent ident1 ident2 (Pnot a) = pnot (substIdent ident1 ident2 a)
substIdent ident1 ident2 x:(Forall ident1 b) = x
substIdent ident1 ident2 (Forall a b) = forall a (substIdent ident1 ident2 b)
substIdent ident1 ident2 (Pelem a b) = pelem (replaceIdent ident1 ident2 a) (replaceIdent ident1 ident2 b)

replaceIdent ident1 ident2 ident1 = ident2
replaceIdent ident1 ident2 * = ident1

hasPident pident:(Pident *) Nil = false
hasPident pident:(Pident *) (Pair a b) = or (hasPident pident a) (hasPident pident b)
hasPident pident:(Pident *) a = hasPident_ pident a
hasPident_ pident:(Pident *) pident = true
hasPident_ pident:(Pident *) (Pident *) = false
hasPident_ pident:(Pident *) (Impl a b) = or (hasPident_ pident a) (hasPident_ pident b)
hasPident_ pident:(Pident *) (Pnot a) = hasPident_ pident a
hasPident_ pident:(Pident *) (Forall * a) = hasPident_ pident a
hasPident_ pident:(Pident *) (Pelem a b) = false

hasFreeIdent ident Nil = false
hasFreeIdent ident (Pair a b) = or (hasFreeIdent ident a) (hasFreeIdent ident b)
hasFreeIdent ident a = hasFreeIdent_ a
hasFreeIdent_ ident (Impl a b) = or (hasFreeIdent_ ident a) (hasFreeIdent_ ident b)
hasFreeIdent_ ident (Pnot a) = hasFreeIdent_ ident a
hasFreeIdent_ ident (Forall ident *) = false
hasFreeIdent_ ident (Forall * a) = hasFreeIdent_ ident a
hasFreeIdent_ ident (Pelem a b) = or (eq a ident) (eq b ident)

availPident expr = availPident_1 a. expr
availPident_1 pident expr = ite (hasPident pident expr)
  availPident_2 availPident_3 pident expr
availPident_2 pident expr = availPident_1 (nextPident pident) expr
availPident_3 pident expr = pident

availPidents expr Zero = nil
availPidents expr (Succ num) = pair
  (availPident expr)
  (availPidents (pair (availPident expr) expr) num)

autoPidentPredPairs predUni predInst = pidentMap2pairs
  (makePidentMap predUni predInst nil)

pidentMap2pairs pidentMap = pidentMap2pairs_1 pidentMap a.
pidentMap2pairs_1 Nil pident = nil
pidentMap2pairs_1 (Pair Nil rest) pident = pidentMap2pairs_1 rest (nextPident pident)
pidentMap2pairs_1 (Pair pred rest) pident = pair
  (pair pident pred)
  (pidentMap2pairs_1 rest (nextPident pident))

makePidentMap (Pident num) pred pidentMap = addToPidentMap (unstrict num) pred pidentMap
makePidentMap (Impl a b) (Impl c d) pidentMap = makePidentMap b d (makePidentMap a c pidentMap)
makePidentMap (Pnot a) (Pnot b) pidentMap = makePidentMap a b pidentMap
makePidentMap (Forall a b) (Forall a c) pidentMap = makePidentMap b c pidentMap
makePidentMap (Pelem a b) (Pelem a b) pidentMap = pidentMap

addToPidentMap Zero pred Nil = pair pred nil
addToPidentMap Zero pred (Pair Nil rest) = pair pred rest
addToPidentMap Zero pred (Pair pred rest) = pair pred rest
addToPidentMap (Succ num) pred Nil = pair nil (addToPidentMap num pred nil)
addToPidentMap (Succ num) pred (Pair a b) = pair a (addToPidentMap num pred b)

----------------------------------------------------------------------------------------------------

Proof:
  rule.inst_ (Proof phi) ident:(Pident *) (Pred p) = Proof (substPident ident p phi)
  rule.mp (Proof (Impl a b)) (Proof a) = Proof b

  ax.prop.1 = Proof (impl a. (impl b. a.))
  ax.prop.2 = Proof (impl (impl a. (impl b. c.)) (impl (impl a. b.) (impl a. c.)))
  ax.prop.3 = Proof (impl (impl (pnot a.) (pnot b.)) (impl b. a.))

rule.inst a b c = rule.inst_ a b (pred c)

proof2pred (Proof a) = pred a

----------------------------------------------------------------------------------------------------

util.inst proof pidentPredPairs = util.inst_1 proof pidentPredPairs
  (availPidents (extract proof) (length pidentPredPairs))
util.inst_1 proof pidentPredPairs avails = util.inst_3
  (util.inst_2 proof pidentPredPairs avails)
  pidentPredPairs avails
util.inst_2 proof Nil Nil = proof
util.inst_2 proof (Pair (Pair pident pred) pidents) (Pair avail avails) =
  util.inst_2 (rule.inst proof pident avail) pidents avails
util.inst_3 proof Nil Nil = proof
util.inst_3 proof (Pair (Pair pident pred) pidents) (Pair avail avails) =
  util.inst_3 (rule.inst proof avail pred) pidents avails

util.ax1 a b = util.inst ax.prop.1 (rawList (pair a. a) (pair b. b) nil)
util.ax2 a b c = util.inst ax.prop.2 (rawList (pair a. a) (pair b. b) (pair c. c) nil)
util.ax3 a b = util.inst ax.prop.3 (rawList (pair a. a) (pair b. b) nil)

util.addSup proof sup = rule.mp
  (util.ax1 (extract proof) sup)
  proof

util.addSup2 proof sup1 sup2 = util.addSup
  (util.addSup proof sup2)
  sup1

util.inst.auto proofUni:(Proof *) predInst = util.inst
  proofUni
  (autoPidentPredPairs (extract proofUni) predInst)

util.infer proofImpl:(Proof (Impl a b)) proofPremise = rule.mp
  (util.inst proofImpl (autoPidentPredPairs a (extract proofPremise)))
  proofPremise

util.infer.ax2 = util.infer th.prop.ax2.a.b.c
util.infer.mpt = util.infer th.prop.mpt
util.infer.reord = util.infer th.prop.reord

util.mid proof:(Proof (Impl a b)) c = rule.mp
  (util.inst th.prop.mid (rawList (pair a. a) (pair b. b) (pair c. c) nil))
  proof

util.mid2 proof a b = util.mid
  (util.mid proof b)
  a

util.impl.refl = rule.inst th.prop.impl.refl a.

util.mp proof1:(Proof (Impl a (Impl b c))) proof2:(Proof (Impl a b)) = rule.mp
  (util.infer.ax2 proof1)
  proof2

----------------------------------------------------------------------------------------------------

-- a -> b -> a
th.prop.ax1.a.b = ax.prop.1

-- (a -> b -> c) -> (a -> b) -> a -> c
th.prop.ax2.a.b.c = ax.prop.2

-- (~a -> ~b) -> b -> a
th.prop.ax3.a.b = ax.prop.3

-- a -> (b -> a) -> a
th.prop.ax1.a.ba = util.ax1 a. (impl b. a.)

-- (a -> (b -> a) -> a) -> (a -> b -> a) -> a -> a
th.prop.ax2.a.ba.a = util.ax2 a. (impl b. a.) a.

-- (a -> b -> a) -> a -> a
th.prop.impl.ax1ab.refl = rule.mp th.prop.ax2.a.ba.a th.prop.ax1.a.ba

-- a -> a
th.prop.impl.refl = rule.mp th.prop.impl.ax1ab.refl th.prop.ax1.a.b

-- (a -> b -> c -> d) -> a -> (b -> c) -> b -> d
th.prop.mpt = rule.mp
  (util.ax2 a. (impl b. (impl c. d.)) (impl (impl b. c.) (impl b. d.)))
  (util.addSup (util.ax2 b. c. d.) a.)

-- (a -> b) -> (b -> c) -> a -> a
th.prop.ab.bc.aa = util.addSup2
  th.prop.impl.refl
  (impl a. b.)
  (impl b. c.)

-- (a -> b) -> a -> b
th.prop.ab.ab = util.impl.refl (impl a. b.)

-- (a -> b) -> a -> b -> c -> b
th.prop.ab.ab.cb = util.addSup2
  (util.ax1 b. c.)
  (impl a. b.)
  a.

-- (a -> b) -> (a -> b) -> a -> c -> b
th.prop.ab.ab.acb = util.infer.mpt th.prop.ab.ab.cb

-- (a -> b) -> a -> c -> b
th.prop.mid = rule.mp
  (util.infer.ax2 th.prop.ab.ab.acb)
  th.prop.ab.ab

-- (a -> b) -> (b -> c) -> a -> a -> b
th.prop.ab.bc.aab = util.mid2
  th.prop.ab.ab
  (impl b. c.)
  a.

-- (a -> b) -> (b -> c) -> a -> b
th.prop.ab.bc.ab = util.mid th.prop.ab.ab (impl b. c.)

-- (a -> b) -> (b -> c) -> a -> b -> c
th.prop.ab.bc.abc = util.addSup
  (util.ax1 (impl b. c.) a.)
  (impl a. b.)

-- (a -> b) -> (b -> c) -> a -> c
th.prop.bc.ab.ac = rule.mp
  (util.infer.ax2 (util.addSup
    th.prop.ax2.a.b.c
    (impl b. c.)))
  (util.ax1 (impl b. c.) a.)

-- (a -> b) -> (c -> a) -> c -> b
th.prop.ab.ca.cb = util.infer.mpt
  (util.ax1 (impl a. b.) c.)

-- (a -> b -> c) -> b -> (a -> b) -> a -> c
th.prop.abc.b.ab.ac = util.mid
  (util.ax2 a. b. c.)
  b.

-- (a -> b -> c) -> (b -> a -> b) -> b -> a -> c
th.prop.abc.bab.bac = util.infer.mpt
  th.prop.abc.b.ab.ac

-- (a -> b -> c) -> b -> a -> c
th.prop.reord = util.mp
  th.prop.abc.bab.bac
  (util.addSup (util.ax1 b. a.) (impl a. (impl b. c.)))

-- a -> (a -> b) -> b
th.prop.a.ab.b = util.infer.reord th.prop.ab.ab

-- ((a -> a) -> b) -> b
th.prop.aa.b.b = rule.mp
  (rule.inst th.prop.a.ab.b a. (impl a. a.))
  th.prop.impl.refl

----------------------------------------------------------------------------------------------------

main = eq (extract th.prop.aa.b.b) (impl (impl (impl a. a.) b.) b.)